import {errorInString} from "./parser_error"

const matchType = /^[a-zA-Z_][a-zA-Z_0-9]*/

/**
 * Check whether the angle brackets in a string are balanced
 * @param string
 */
function checkAngleBracketsBalanced(string) {
  const stack = []

  let i = 0

  for (; i < string.length; ++i) {
    let char = string[i]

    switch (char) {
      case '<':
        stack.push('<')
        break
      case '>':
        const last = stack.pop()

        if (last === '<')
          break

        throw errorInString(string, i, 'Unbalanced angle brackets in type definition')
    }
  }

  if (stack.length === 0)
    return

  throw errorInString(string, i, 'Unbalanced angle brackets in type definition')
}

const tokenizerStrings = ['<', '>', '::', ',']

export function* typeTokenizer(string) {
  checkAngleBracketsBalanced(string)

  string = string.trimEnd()

  let i = 0
  let prevLen = string.length

  const originalString = string

  main: while (string) {
    string = string.trim()

    i += prevLen - string.length
    prevLen = string.length

    for (const token of tokenizerStrings) {
      if (string.startsWith(token)) {
        yield {
          type: token,
          index: i
        }

        string = string.slice(token.length)

        continue main
      }
    }

    // If none of those tokens were matched, we either have a type or an invalid token

    const match = matchType.exec(string)

    if (match) {
      yield {
        type: 'type',
        index: i,
        str: match[0]
      }
    } else throw errorInString(originalString, i, 'Unrecognized token in type definition')

    string = string.slice(match[0].length)
  }
}

/**
 * Class abstracting the concept of a type. For example, real, complex, bool, list::<real>, pair::<list::<real>, real>
 */
class Type {
  constructor(str, children = []) {
    this.str = str

    // Type checking for children
    if (children !== null && !Array.isArray(children))
      throw new TypeError("children must either be null or an array")

    this.children = children
  }

  // Apply callback to all children. We can use recursion since Grapheme asserts that max template depth <= 512
  applyAll(callback) {
    callback(this)

    if (this.children) {
      this.children.forEach(child => child.applyAll(callback))
    }
  }

  // Clone the type
  clone() {
    return new Type(this.str,
      this.children ? this.children.map(child => child.clone()) : null)
  }

  // Number of template arguments in this type
  argCount() {
    return this.children ? this.children.length : 0
  }

  // Deep equals between Types. Could also compare by string, but that's slower
  equals(type) {
    if (type.str !== this.str || this.argCount() !== type.argCount())
      return false

    return this.children.every((child, i) => child.equals())
  }

  // Whether the type has a template specialization
  hasChildren() {
    return this.children && this.children.length !== 0
  }

  toString() {
    let ret = this.str

    if (this.hasChildren()) {
      ret += "::<" + this.children.map(child => child.toString()).join(", ") + '>'
    }

    return ret
  }

  /**
   * Replace empty arrays in children with
   * @private
   */
  replaceEmptyChildrenWithNull() {
    this.applyAll(child => {
      if (!child.hasChildren()) {
        child.children = null
      }
    })
  }
}

/**
 * Convert string to Type object
 * @param string
 * @returns {Type}
 */
function parseType(string) {
  return parseTypeFromTokens(Array.from(typeTokenizer(string)), string)
}

const signifiersOfTemplatelessType = ['>', ',']

/**
 * Convert a tokenized type into an actual Type object.
 * @param tokens {Array} List of tokens, generated by typeTokenizer
 * @param originalString {String} The original string to be parsed, used for informative error messages
 */
function parseTypeFromTokens(tokens, originalString) {
  // This happens when there's an error in typeTokenizer, so just return since onParserError was already called
  if (!tokens)
    return null

  // Stack of types used during construction
  const constructionStack = []
  const overallType = tokens[0].str

  if (!overallType)
    throw errorInString(originalString, tokens[0].index, "First token must be a type")

  // If the type is just a simple string, return it
  if (tokens.length === 1)
    return new Type(overallType, null)

  let current = new Type(overallType)
  const ret = current

  const lastToken = tokens[tokens.length - 1]

  if (lastToken.type !== '>')
    throw errorInString(originalString, lastToken.index, "Last token of a template must be >")

  let currentReadyForSpecialization = false

  constructionStack.push(current)

  function peek() {
    return constructionStack[constructionStack.length - 1]
  }

  for (let i = 1; i < tokens.length; ++i) {
    const token = tokens[i]

    if (token.type === "::") {
      if (currentReadyForSpecialization)
        throw errorInString(originalString, token.index, "Successive ::")

      currentReadyForSpecialization = true
      const nextToken = tokens[i + 1]

      if (nextToken.type !== '<')
        throw errorInString(originalString, token.index, ":: must always be followed by <")
    } else if (token.type === "<") {
      if (!currentReadyForSpecialization)
        throw errorInString(originalString, token.index, "Starting angle bracket immediately after type name; probably missing ::")

      currentReadyForSpecialization = false
    } else if (token.type === ">") {
      constructionStack.pop()

      current = peek()
    } else if (token.type === "type") {
      const type = new Type(token.str, [])
      const nextToken = tokens[i + 1]

      if (nextToken) {
        peek().children.push(type)

        if (!signifiersOfTemplatelessType.includes(nextToken.type)) {
          current = type
          constructionStack.push(current)


          currentReadyForSpecialization = false
        }
      }
    }
  }

  ret.replaceEmptyChildrenWithNull()

  return ret
}

export {parseType}
